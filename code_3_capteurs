/*
        PROGRAMME AVEC LES 3 PREMIERS CAPTEURS ir4 ir3 ir2 et ir0 capteur à droite  :-) 
 */

#include <ArduinoRobot.h>
#include <Wire.h>
#include <SPI.h>

// DECLARATION DES VALEURS POUR LES CAPTEURS

int ir0;
int ir1;
int ir2;
int ir3;
int ir4;
int vit;
int arriver = 0;



//**************************************
//*               SETUP                *
//**************************************

void setup()
{
  Robot.begin();
  Robot.beginTFT();
  Serial.begin(9600);

//POTENTIOMETRE
  vit = Robot.knobRead() ; // cette valeur est compris entre 0 et 1023
  vit = map(vit, 0, 1023, 50, 255); // la fonction va permettre de changer la valeur de 0 à 1023 vers une valeur de 0 à 255 (mise à l echelle)
   
}

//**************************************
//*                LOOP                *
//**************************************
void loop(){

  // etat des capteurs
  if (Robot.IRarray[0] < 400){ ir0 = 1; } else { ir0 = 0; }
  if (Robot.IRarray[1] < 400){ ir1 = 1; } else { ir1 = 0; }
  if (Robot.IRarray[2] < 400){ ir2 = 1; } else { ir2 = 0; }
  if (Robot.IRarray[3] < 400){ ir3 = 1; } else { ir3 = 0; }
  if (Robot.IRarray[4] < 400){ ir4 = 1; } else { ir4 = 0; }
 

 // ici c'est plus chercher le plus faible avec un for et faire un switch case .....
 // ir0 ir1 ir2 ir3 ir4 sont des booleans s'il capte une ligne ou pas


//**************************************
//*      TRAITEMENT DES CAPTEURS       *
//**************************************

  //traitement cas arriver
  if (ir4 == 1 && ir3 == 1 && ir2 == 1 && ir1 == 1 && arriver == 0){ // && ir0 == 1 ) le probleme est que l'arriver risque de pas etre assez large :/
    avancer_arriver();
    //mise à jour des capteurs
    if (Robot.IRarray[0] < 400){ ir0 = 1; } else { ir0 = 0; }
    if (Robot.IRarray[1] < 400){ ir1 = 1; } else { ir1 = 0; }
    if (Robot.IRarray[2] < 400){ ir2 = 1; } else { ir2 = 0; }
    if (Robot.IRarray[3] < 400){ ir3 = 1; } else { ir3 = 0; }
    if (Robot.IRarray[4] < 400){ ir4 = 1; } else { ir4 = 0; }

    if (ir4 == 1 && ir3 == 1 && ir2 == 1 && ir1 == 1){  // && ir0 == 1 ) le probleme est que l'arriver risque de pas etre assez large :/
      arriver = 1;
    }
  }

// s'il y a pas d'arriver
  if(arriver == 0){
    if(ir0 == 1){
      // priorité si capteur 0 détecté tourne a droite 
      tourne_a_droite();
    }
    else if(ir4 == 1 && ir3 == 1 && ir2 == 1){
      // le cas où tout est normal (pas besoin de specifié ir0 on est toujours dans la boucle)
        avance_tout_droit(); 
    }
    // ici nous sommes dans le cas suivant ir0 = 0 , mais pas ir4 == 1 && ir3 == 1 && ir2 == 1
    else if ( ir4 == 0 && ir3 == 0 && ir2 == 0 && ir1 == 0){
      //ici pas de ligne, le seul cas possible c'est un virage à gauche :) quel genie ce MEHREZ POPOPO CHALEUR !!!!
      recule(); // necessaire car le robot a avancé plus loin que la ligne
      tourne_a_gauche(); 
    }
    else if (ir4 == 0){
      tourne_a_droite(); 
    }
    else if (ir2 == 0){
        tourne_a_gauche(); 
    }
    else{
      gros_probleme(); //normalement impossible (tout les test d'avant faux)
    }
  }

// arrete le robot s'il est arriver
  while (arriver ==  1) {
    arrete_toi();
  }

}

//**************************************
//*           LES FONCTIONS            *
//**************************************

//la vitesse de la roue faible lors d'une rotation
int vitesse2 = 60;

// ARRIVER
void arrete_toi() 
{ 
  Robot.motorsWrite(0,0); 
  delay(500); 
} 

// AVANCE ARRIVER
void avancer_arriver() 
{ 
  Robot.motorsWrite(80,80); 
  delay(1000); 
  Robot.motorsStop();
} 

// RECULE
void recule() 
{ 
  Robot.motorsWrite(-80,-80); 
  delay(1000); 
}

// AVANCE
void avance_tout_droit() 
{ 
  // Robot.motorsStop();
  Robot.motorsWrite(vit,vit); 
  delay(500); 
}  

// TOURNE À DROITE
void tourne_a_droite() 
{ 
  // Robot.motorsStop();
  Robot.motorsWrite(vit,vitesse2); 
  delay(500); 
}  

// TOURNE À GAUCHE
void tourne_a_gauche() 
{ 
  // Robot.motorsStop();
  Robot.motorsWrite(vitesse2,vit); 
  delay(500);  
} 

// CAS OU IL Y A UNE ERRER DE PROGRAMMATION
void gros_probleme(){
  Robot.motorsWrite(240, 240); 
  delay(10000);  
}
